在多用户DBS中，如果多个用户同时对同一数据进行操作称为并发操作 
并发操作使多个事务之间可能产生相互干扰，破坏事务的隔离性（Isolation）

并发操作通常会引起几类问题 
假设有一个order表，有个字段叫count，作为计数用，当前值为100

第一类丢失更新（Update Lost）：此种更新丢失是因为回滚的原因，所以也叫回滚丢失。此时两个事务同时更新count，两个事务都读取到100，事务一更新成功并提交，count=100+1=101，事务二出于某种原因更新失败了，然后回滚，事务二就把count还原为它一开始读到的100，此时事务一的更新就这样丢失了。

脏读（Dirty Read）：此种异常时因为一个事务读取了另一个事务修改了但是未提交的数据。举个例子，事务一更新了count=101，但是没有提交，事务二此时读取count，值为101而不是100，然后事务一出于某种原因回滚了，然后第二个事务读取的这个值就是噩梦的开始。

不可重复读（Not Repeatable Read）：此种异常是一个事务对同一行数据执行了两次或更多次查询，但是却得到了不同的结果，也就是在一个事务里面你不能重复（即多次）读取一行数据，如果你这么做了，不能保证每次读取的结果是一样的，有可能一样有可能不一样。造成这个结果是在两次查询之间有别的事务对该行数据做了更新操作。举个例子，事务一先查询了count，值为100，此时事务二更新了count=101，事务一再次读取count,值就会变成101，两次读取结果不一样。

第二类丢失更新（Second Update Lost）：此种更新丢失是因为更新被其他事务给覆盖了，也可以叫覆盖丢失。举个例子，两个事务同时更新count，都读取100这个初始值，事务一先更新成功并提交，count=100+1=101，事务二后更新成功并提交，count=100+1=101,由于事务二count还是从100开始增加，事务一的更新就这样丢失了。

幻读（Phantom Read）：幻读和不可重复读有点像，只是针对的不是数据的值而是数据的数量。此种异常是一个事务在两次查询的过程中数据的数量不同，让人以为发生幻觉，幻读大概就是这么得来的吧。举个例子，事务一查询order表有多少条记录，事务二新增了一条记录，然后事务一查了一下order表有多少记录，发现和第一次不一样，这就是幻读。

数据库事务隔离级别
看到上面提到的几种问题，你可能会想，我擦，这么多坑怎么办啊。其实上面几种情况并不是一定都要避免的，具体看你的业务要求，包括你数据库的负载都会影响你的决定。不知道大家发现没有，上面各种异常情况都是多个事务之间相互影响造成的，这说明两个事务之间需要某种方式将他们从某种程度上分开，降低直至避免相互影响。这时候数据库事务隔离级别就粉墨登场了，而数据库的隔离级别实现一般是通过数据库锁实现的。

读未提交（Read Uncommitted）：该隔离级别指即使一个事务的更新语句没有提交,但是别的事务可以读到这个改变，几种异常情况都可能出现。极易出错，没有安全性可言，基本不会使用。

读已提交（Read Committed）：该隔离级别指一个事务只能看到其他事务的已经提交的更新，看不到未提交的更新，消除了脏读和第一类丢失更新，这是大多数数据库的默认隔离级别，如Oracle,Sqlserver。

可重复读（Repeatable Read）：该隔离级别指一个事务中进行两次或多次同样的对于数据内容的查询，得到的结果是一样的，但不保证对于数据条数的查询是一样的，只要存在读改行数据就禁止写，消除了不可重复读和第二类更新丢失，这是Mysql数据库的默认隔离级别。

串行化（Serializable）：意思是说这个事务执行的时候不允许别的事务并发执行.完全串行化的读，只要存在读就禁止写,但可以同时读，消除了幻读。这是事务隔离的最高级别，虽然最安全最省心，但是效率太低，一般不会用。

调度: 多个事务的读写操作按时间排序的执行序列
调度中每个事务的读写操作保持原来顺序 
事务调度时不考虑:
 数据库的初始状态 (Initial state) 事务的语义 (Transaction semantics)

2、What is a correct schedule? Answer: 
  a serializable schedule!
串行调度 (Serial schedule) 各个事务之间没有任何操作交错执行，事务一个一个执行 S ＝ T1 T2 T3 … Tn
  如果一个调度的结果与某一串行调度执行的结果等价，则称该调度是可串化调度，否则是不可串调度

3、冲突可串性 (conflict serializable)
冲突操作： 涉及同一个数据库元素，并且至少有一个是写操作
  如果调度中一对连续操作是冲突的，则意味着如果它们的执行顺序交换，则至少会改变其中一个事务的最终执行结果 
  如果两个连续操作不冲突，则可以在调度中交换顺序

冲突等价 (conflict equivalent )：
  S1, S2 are conflict equivalent schedules if S1 can be transformed into S2 by a series of swaps on non-conflicting actions.

冲突可串性 (conflict serializable)：
  A schedule is conflict serializable if it is conflict equivalent to some serial schedule.

优先图用于冲突可串性的判断
优先图结构 
结点 (Node)：事务
有向边 (Arc): Ti -> Tj ，满足 Ti <s Tj 
存在Ti中的操作A1和Tj中的操作A2，满足 A1在A2前，并且 A1和A2是冲突操作

给定一个调度S，构造S的优先图P(S)，若P(S)中无环，则S满足冲突可串性

数据库锁分类
一般可以分为两类，一个是悲观锁，一个是乐观锁，悲观锁一般就是我们通常说的数据库锁机制，乐观锁一般是指用户自己实现的一种锁机制，比如hibernate实现的乐观锁甚至编程语言也有乐观锁的思想的应用。

悲观锁：顾名思义，就是很悲观，它对于数据被外界修改持保守态度，认为数据随时会修改，所以整个数据处理中需要将数据加锁。悲观锁一般都是依靠关系数据库提供的锁机制，事实上关系数据库中的行锁，表锁不论是读写锁都是悲观锁。

悲观锁按照使用性质划分：
共享锁（Share locks简记为S锁）：也称读锁，事务A对对象T加s锁，其他事务也只能对T加S，多个事务可以同时读，但不能有写操作，直到A释放S锁。

排它锁（Exclusivelocks简记为X锁）：也称写锁，事务A对对象T加X锁以后，其他事务不能对T加任何锁，只有事务A可以读写对象T直到A释放X锁。

更新锁（简记为U锁）：用来预定要对此对象施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的对象将要被更新时，则升级为X锁，主要是用来防止死锁的。因为使用共享锁时，修改数据的操作分为两步，首先获得一个共享锁，读取数据，然后将共享锁升级为排它锁，然后再执行修改操作。这样如果同时有两个或多个事务同时对一个对象申请了共享锁，在修改数据的时候，这些事务都要将共享锁升级为排它锁。这些事务都不会释放共享锁而是一直等待对方释放，这样就造成了死锁。如果一个数据在修改前直接申请更新锁，在数据修改的时候再升级为排它锁，就可以避免死锁。

悲观锁按照作用范围划分：
行锁：锁的作用范围是行级别，数据库能够确定那些行需要锁的情况下使用行锁，如果不知道会影响哪些行的时候就会使用表锁。举个例子，一个用户表user，有主键id和用户生日birthday当你使用update … where id=?这样的语句数据库明确知道会影响哪一行，它就会使用行锁，当你使用update … where birthday=?这样的的语句的时候因为事先不知道会影响哪些行就可能会使用表锁。
表锁：锁的作用范围是整张表。

乐观锁：顾名思义，就是很乐观，每次自己操作数据的时候认为没有人回来修改它，所以不去加锁，但是在更新的时候会去判断在此期间数据有没有被修改，需要用户自己去实现。既然都有数据库提供的悲观锁可以方便使用为什么要使用乐观锁呢？对于读操作远多于写操作的时候，大多数都是读取，这时候一个更新操作加锁会阻塞所有读取，降低了吞吐量。最后还要释放锁，锁是需要一些开销的，我们只要想办法解决极少量的更新操作的同步问题。换句话说，如果是读写比例差距不是非常大或者你的系统没有响应不及时，吞吐量瓶颈问题，那就不要去使用乐观锁，它增加了复杂度，也带来了额外的风险。

乐观锁实现方式：
版本号（记为version）：就是给数据增加一个版本标识，在数据库上就是表中增加一个version字段，每次更新把这个字段加1，读取数据的时候把version读出来，更新的时候比较version，如果还是开始读取的version就可以更新了，如果现在的version比老的version大，说明有其他事务更新了该数据，并增加了版本号，这时候得到一个无法更新的通知，用户自行根据这个通知来决定怎么处理，比如重新开始一遍。这里的关键是判断version和更新两个动作需要作为一个原子单元执行，否则在你判断可以更新以后正式更新之前有别的事务修改了version，这个时候你再去更新就可能会覆盖前一个事务做的更新，造成第二类丢失更新，所以你可以使用update … where … and version=”old version”这样的语句，根据返回结果是0还是非0来得到通知，如果是0说明更新没有成功，因为version被改了，如果返回非0说明更新成功。

时间戳（timestamp）：和版本号基本一样，只是通过时间戳来判断而已，注意时间戳要使用数据库服务器的时间戳不能是业务系统的时间。

待更新字段：和版本号方式相似，只是不增加额外字段，直接使用有效数据字段做版本控制信息，因为有时候我们可能无法改变旧系统的数据库表结构。假设有个待更新字段叫count,先去读取这个count,更新的时候去比较数据库中count的值是不是我期望的值（即开始读的值），如果是就把我修改的count的值更新到该字段，否则更新失败。java的基本类型的原子类型对象如AtomicInteger就是这种思想。

所有字段：和待更新字段类似，只是使用所有字段做版本控制信息，只有所有字段都没变化才会执行更新。

乐观锁几种方式的区别：
新系统设计可以使用version方式和timestamp方式，需要增加字段，应用范围是整条数据，不论那个字段修改都会更新version,也就是说两个事务更新同一条记录的两个不相关字段也是互斥的，不能同步进行。旧系统不能修改数据库表结构的时候使用数据字段作为版本控制信息，不需要新增字段，待更新字段方式只要其他事务修改的字段和当前事务修改的字段没有重叠就可以同步进行，并发性更高。

Lock Granularity 指加锁的数据对象的大小 可以是整个关系、块、元组、整个索引、索引项
 锁粒度越细，并发度越高；锁粒度越粗，并发度越低

多粒度锁协议MGL 允许多粒度树中的每个结点被独立地加S锁或X锁，对某个结点加锁意味着其下层结点也被加了同类型的锁

普通锁Lock只能针对已存在的元组，对于开始时不存在后来被插入的元组无法Lock
所以需要MGL！！
多粒度锁上的两种不同加锁方式 
  显式加锁：应事务的请求直接加到数据对象上的锁
  隐式加锁：本身没有被显式加锁，但因为其上层结点加了锁而使数据对象被加锁
给一个结点显式加锁时必须考虑 该结点是否已有不相容锁存在 上层结点是否已有不相容的的锁（上层结点导致的隐式锁冲突） 所有下层结点中是否存在不相容的显式锁

理论上要搜索上面全部的可能情况，才能确定P上的锁请求能否成功 显然是低效的 
引入意向锁 (Intension Lock) 解决这一问题
 IS锁（Intent Share Lock，意向共享锁，意向读锁）
 IX锁（Intent Exlusive Lock，意向排它锁，意向写锁）
如果对某个结点加IS(IX)锁，则说明事务要对该结点的某个下层结点加S (X)锁；
对任一结点P加S(X)锁，必须先对从根结点到P的路径上的所有结点加IS(IX)锁


分布式数据库：
定义：物理上分布而逻辑上集中的数据库系统 
 每个站点(Site)自身具有完全的本地DBS 
 所有站点协同工作，组成了逻辑上的统一数据库 
 站点数据由分布式DBMS(DDBMS)管理——DBMS+分布式扩展模块 
 本地应用和本地用户(Local) 只访问其所注册的那个站点上的数据 
 全局应用和全局用户(Global) 访问涉及多个站点上的数据

特点：
 物理分布性 逻辑整体性 站点自治性 数据透明性
数据透明性：
 位置透明性 用户无须知道数据的物理存储位置（站点） 
 复制透明性 DDBS通过数据复制来提高系统可用性。但用户不必关系复制了什么数据对象以及副本存储在什么位置 
 分片透明性 数据分片：将数据分割成不同的片断，例如将CS学生存在站点A，EE学生存在站点B 用户无须知道数据是如何分片的

分区
就是把一张表的数据分成N个区块，在逻辑上看最终只是一张表，但底层是由N个物理区块组成的

分表
就是把一张表按一定的规则分解成N个具有独立存储空间的实体表。系统读写时需要根据定义好的规则得到对应的字表明，然后操作它。

分库
一旦分表，一个库中的表会越来越多


1、数据分片：
 分布式数据库中，全局DB是由各个局部DB逻辑组合而成的，局部DB是全局DB的某种逻辑分割
 数据分片就是将数据分割成一个个逻辑片断，可通过关系代数来实现

数据分片方法
 水平分片（分割行）：分割成不相交的元组集合，每个子集为一个逻辑片段 可通过选择运算来实现 全局关系可通过分片的Union来得到    
 垂直分片（分割列）：把全局关系的属性集分成若干子集，可通过投影运算来实现 全局关系的每个属性至少映射到一个片段上，且每个片段应包含全局关系的码 全局关系可通过分片的自然连接得到（无损） 混合分片：先水平后垂直/先垂直后水平

2、数据分配
将数据分片分散存储到各个站点的策略
数据分配的策略 
 集中式：所有分片都安排在同一站点上 易管理，一致性易保证，但可靠性差 
 分割式：每个分片分配存储到某个特定站点上 可充分利用站点存储资源，部分站点故障时系统仍可运行，可靠性较好。但全局查询代价高。 
 复制式：每个分片在所有站点都有副本 可靠性高，响应快。数据同步代价高，冗余大。 
 混合式：所有分片划分成若干子集，每个子集存储于1个或多个站点上 灵活性好，兼有分割式和复制式优点。但同时也兼有两者缺点。

3、分库
什么时候考虑使用分库？
单台DB的存储空间不够
随着查询量的增加单台数据库服务器已经没办法支撑
分库解决的问题
其主要目的是为突破单节点数据库服务器的 I/O 能力限制，解决数据库扩展性问题。 

垂直拆分
将系统中不存在关联关系或者需要join的表可以放在不同的数据库不同的服务器中。

按照业务垂直划分。比如：可以按照业务分为资金、会员、订单三个数据库。

需要解决的问题：跨数据库的事务、jion查询等问题。

水平拆分
例如，大部分的站点。数据都是和用户有关，那么可以根据用户，将数据按照用户水平拆分。

按照规则划分，一般水平分库是在垂直分库之后的。比如每天处理的订单数量是海量的，可以按照一定的规则水平划分。需要解决的问题：数据路由、组装。

读写分离
对于时效性不高的数据，可以通过读写分离缓解数据库压力。需要解决的问题：在业务上区分哪些业务上是允许一定时间延迟的，以及数据同步问题。

4、数据存储的演进
单库单表
单库单表是最常见的数据库设计，例如，有一张用户(user)表放在数据库db中，所有的用户都可以在db库中的user表中查到。

单库多表
随着用户数量的增加，user表的数据量会越来越大，当数据量达到一定程度的时候对user表的查询会渐渐的变慢，从而影响整个DB的性能。如果使用mysql, 还有一个更严重的问题是，当需要添加一列的时候，mysql会锁表，期间所有的读写操作只能等待。

可以通过某种方式将user进行水平的切分，产生两个表结构完全一样的user_0000,user_0001等表，user_0000 + user_0001 + …的数据刚好是一份完整的数据。

多库多表
随着数据量增加也许单台DB的存储空间不够，随着查询量的增加单台数据库服务器已经没办法支撑。这个时候可以再对数据库进行水平拆分


OODB：面向对象数据库
一个允许我们在关系中自由使用集合和列表的类型系统。提供了复杂类型系统，支持集合、列表等类型
持久化OO语言： 与OO语言相关，增加持久化支持 一般只支持C++和Java
不支持SQL标准

ORDB：RDB(Relational Database关系型数据库)+OO(Object Oriented面向对象的)
 关系表的列可以是新的抽象数据类型(ADT)
 用户可以增加新的ADT以及定义ADT上的操作
 支持引用类型、继承
 支持SQL语言
